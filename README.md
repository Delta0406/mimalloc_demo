# mimalloc为什么会比malloc产生更少的内存碎片？
## 1.内存分配器的核心任务
内存分配器的任务是：
> 在应用程序多次 malloc() / free() 的请求下， 高效地复用堆内存，避免浪费和碎片。

碎片主要分为两类：
* 内部碎片：分配的块大于用户实际需要；
* 外部碎片：空闲内存分散、无法整合成可用大块。

## 2.malloc的内存组织方式
(1) 堆结构与动态切割
传统 malloc 将整个堆视为一大片连续虚拟内存：
```css
|-------------------------- Heap --------------------------|
```
当用户请求 malloc(size) 时：
* 分配器从空闲区域（free chunk）中找到一个足够大的空洞；
* 如果空洞大于请求，则切割一部分；
* 剩余部分重新加入空闲链表。
→ 这就是“动态切割堆”的分配策略。

(2) bin的真正含义
为了提高查找效率，malloc 会维护多个 bin（大小类链表）：
* 每个 bin 管理一组相似大小的空闲块；
> 例如：bin[32] 存放 24~32 字节的空闲块，bin[64] 存放 40~64 字节的空闲块。
重要的是：
> 这些 bin 只是逻辑分类（链表），并不是物理上连续的内存区域。
这些内存块在虚拟内存中可能如下分布：
```css
bin[32] →  [0x1000] → [0x801000] → [0x1A2000]
bin[64] →  [0x1020] → [0x802000]
```
同一个 bin 的块可能相隔几 MB，它们来自堆上不同位置。

(3) 碎片产生的根源
因为 malloc 只是“动态切堆 + 链表索引”，没有真正的空间隔离：
* 不同大小的对象混合放在同一片堆空间；
* 不同生命周期对象交错存在；
* 释放后形成空洞，被其他大小阻断，难以合并。
例子：
```css
|---32B---|---64B---|---32B---|---64B---|
free(32B, 32B)
→ |---空洞---|---64B---|---空洞---|---64B---|
```
两个空洞被64B阻隔，无法合并或整页释放。形成外部碎片。

## 3. mimalloc的思路：物理分区 + 固定大小类
mimalloc 重新设计了整个空间布局，核心思想是：
> 不再让不同大小对象混合在一块堆中，
> 而是让每种大小的对象有独立的“家”。

(1) Size Class（固定大小类）
mimalloc 将所有分配请求量化到一组固定大小：
```css
16B, 24B, 32B, 40B, 48B, 56B, ...
```
例如用户申请 33B，会分到 40B 类。 （确实会有一点点内部碎片，但可控且稳定。）

(2) Page管理机制
每个大小类（size class）有自己的一组 page：
* 每个 page（如 16KB）只存放该类对象；
* 一个 page 被划分为固定数量的 slot：
```css
Page(32B class): [slot][slot][slot]...
```
* 分配时取空 slot；
* 释放时slot回收
* 整页空闲时直接释放回操作系统
即每个 bin 对应独立的物理 page 区域。

(3) 优势：碎片最小化
由于不同大小的对象从物理上完全隔离：
* 不会混合存放 → 避免跨类空洞；
* 不会被阻断 → 同类空洞可直接复用；
* page 粒度可整页回收 → 外部碎片极小；
* 内部碎片固定上界 → 稳定可控。

# 4. malloc vs mimalloc对比表
|   特征    |  malloc   |      mimalloc       |
|:-------:|:---------:|:-------------------:|
|  Bin定义  |  逻辑链表索引   |    物理分区（Page集合）     | 
|  分配策略   |  动态切割堆内存  |      预分配固定大小类       |
|  同类块布局  |   离散、混合   |       局部连续、独立       |
|  可整页回收  |    难实现    |        容易实现         |
|  内部碎片   | 对齐导致中等浪费  | 由size class限定，小且稳定  |
|  外部碎片   |  高，随时间增长  |       极低，长期稳定       | 